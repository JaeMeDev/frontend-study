# 🌸 Chapter 3: 액션과 계산, 데이터의 차이를 알기

## 🍄 1. 액션과 계산 데이터

- 함수형 프로그래머는 액션과 계산, 데이터를 구분한다.
- **액션**
    - 실행 시점과 횟수에 의존한다.
    - 다른 말로 부수효과(side effects), 부수 효과가 있는 함수(side-effecting function), 순수하지 않은 함수(impure function)라고 부르기도 한다.
    - 예 : 이메일 보내기, 데이터베이스 읽기
- **계산**
    - 입력으로 출력을 계산한다.
    - 다른 말로 순수 함수(pure function), 수학 함수(pure function)라 부르기도 한다.
    - 예 : 최댓값 찾기, 이메일 주소가 올바른지 확인하기
- **데이터**
    - 이벤트에 대한 사실
    - 예 : 사용자가 입력한 이메일 주소, 은행 API로 읽은 달러 수량
- 모든 개발 과정에서 액션과 계산, 데이터를 구분하는 기술을 적용할 수 있다.
- 계산은 계산을 호출하는 코드를 계산 결과를 바꿀 수 있기 때문에 **참조 투명**하다.

### 🌻 1-1. 문제에 대해 생각할 때

- 코딩을 시작하기 전이고 문제에 대해서 고민하고 있을 때도 문제를 액션과 계산, 데이터로 나눠 생각해 볼 수 있다.
- 문제를 액션과 계산, 데이터로 나눠보면 코드를 작성할 때 특별히 주의해야 할 부분(액션)과 데이터로 처리해야 할 부분, 결정을 내려야 하는 부분(계산)을 명확히 알 수 있다.

### 🌻 1-2. 코딩할 때

- 코딩을 할 때도 액션과 계산, 데이터를 구분할 수 있다.
- 함수형 프로그래머는 최대한 액션에서 계산을 빼내려 한다. 또 계산에서는 데이터를 분리할 수 있는지 생각한다.
- 액션이 계산이 될 수 있는지, 계산은 데이터가 될 수 있는지 고민한다.

### 🌻 1-3. 코드를 읽을 때

- 코드를 읽을 때 액션과 계산, 데이터 중 어떤 것에 속하는지 잘 살펴봐야 한다. 특히 액션은 시간에 의존하기 때문에 더 조심해야 한다.
- 함수형 프로그래머는 더 좋은 코드를 만들기 위해 이미 있는 코드를 액션과 계산, 데이터로 리팩터링 하는 방법을 찾을 것이다.

## 🍄 2. 액션과 계산, 데이터는 어디에나 적용할 수 있다.

- 장보기에 액션과 계산, 데이터를 적용해보자.
- 일반 프로그래머가 장보기 과정을 그린다면 이처럼 그릴 수 있다.
- 장보기 과정
    1. 냉장고 확인하기(액션) : 냉장고를 확인하는 시점에 따라 냉장고에 있는 제품이 다르다.
    2. 운전해서 상점으로 가기(액션) : 두 번 운전해서 상점에 가면 연료가 두 배로 든다.
    3. 필요한 것 구입하기(액션) : 구입하는 것도 구입하는 시점에 따라 물건이 있을지 없을지 모른다.
    4. 운전해서 집으로 오기(액션) : 이미 집에 있다면 상점에 있는 것이 아니기 때문에 상점에서 집으로 올 수 없다.

### 🌻 2-1. 냉장고 확인하기

- 냉장고를 확인하는 일은 확인하는 시점이 중요하기 때문에 액션이다.
- 냉장고에 가지고 있는 제품은 데이터이다. 이것을 현재 재고라고 하자.

### 🌻 2-2. 운전해서 상점으로 가기

- 운전해서 상점으로 가는 것은 복잡한 행동이고 명확히 액션이다.
- 상점 위치나 가는 경로는 데이터로 볼 수 있다.

### 🌻 2-3. 필요한 것 구입하기

- 구입하는 일도 액션이다. 하지만 구입 과정은 몇 단계로 나눌 수 있다.
- 필요한 재고 - 현재 재고 = 장보기 목록
- 앞에 “냉장고 확인하기”단계에서 현재 재고 데이터를 사용했다. 이 데이터를 활용해 단계를 나눌 수 있다.
    - 데이터 : 현재 재고
    - 데이터 : 필요한 재고
    - 계산 : 재고 “빼기”
    - 데이터 : 장보기 목록
    - 액션 : 목록에 있는 것 구입하기

### 🌻 2-4. 운전해서 집으로 오기

- 운전해서 집으로 오는 단계는 더 나눌 수 있지만 다루려고 하는 범위가 아니다.
- 장보기 과정 정리
- **액션**
    - 냉장고 확인
    - 운전해서 상점으로 가기
    - 목록에 있는 것 구입하기
    - 운전해서 집으로 오기
- **계산**
    - 재고 빼기
- **데이터**
    - 현재 재고
    - 필요한 재고
    - 장보기 목록
- 이런 과정을 반복하면 액션과 계산, 데이터를 더 많이 찾을 수 있고 풍부한 모델을 만들 수 있다.
- 계속 나누다 보면 더 복잡해진다고 생각할 수 있지만 액션에 숨어 있는 다른 액션이나 계산 또는 데이터를 발견하기 위해 나눌 수 있는 만큼 나누는 것이 좋다.

## 🍄 3. 데이터에 대해 자세히 알아보기

- 데이터는 이벤트에 대한 사실이다. 일어난 일의 결과를 기록한 것이다.
- 데이터는 자바스크립트에서 기본 데이터 타입으로 구현한다. 숫자나 문자, 배열, 객체 같은 것이다.
- 데이터는 데이터 구조로 의미를 담을 수 있다. 예를 들어 목록의 순서가 중요하다면 순서를 보장하는 데이터 구조를 사용하면 된다. 데이터 구조로 도메인을 표현할 수 있다.
- 함수형 프로그래머는 불변 데이터 구조를 만들기 위해 두 가지 원칙을 사용한다.
    1. **카피-온-라이트** : 변경할 때 복사본을 만든다.
    2. **방어적 복사** : 보관하려고 하는 데이터의 복사본을 만든다.
- 데이터의 예로는 구입하려는 음식  목록, 이름, 전화 번호, 음식 조립법이 있다.
- 데이터의 장점
    1. **직렬화** : 직렬화된 액션과 계산은 다른 곳에서 잘 동작할 것이라는 보장이 없다. 하지만 직렬화된 데이터는 전송하거나 디스크에 저장했다가 읽기 쉽다.
    2. **동일성 비교** : 계산이나 액션은 서로 비교하기 어렵다. 하지만 데이터는 비교하기 쉽다.
    3. **자유로운 해석** : 데이터는 여러가지 방법으로 해석할 수 있다. 접속 로그는 문제 해결을 위해 사용할 수 있지만, 모니터링을 위해 사용할 수 있다.
- 데이터는 유연하게 해석할 수 있다는 점은 장점이지만, 해석이 반드시 필요하다는 점은 단점이다. 계산은 해석하지 않아도 실행할 수 있다. 하지만 해석하지 않은 데이터는 쓸모없는 바이트일 뿐이다.

## 🍄 4. 새로 만드는 코드에 함수형 사고 적용하기

- 쿠폰독은 쿠폰에 관심 있는 구독자들에게 이메일로 쿠폰을 매주 보내주는 서비스이다. 사용자도 많고 인기있는 서비스이다.
- 쿠폰독 CMO는 사용자를 더 늘리기 위해 친구 10명을 추천하면 더 좋은 쿠폰을 보내주려 한다.
- 쿠폰독은 커다란 이메일 데이터베이스가 있다. 여기에는 이메일별로 각 사용자가 추천한 친구도 기록하고 있다.
- 쿠폰에 대한 정보를 가지고 있는 데이터베이스도 있다. 쿠폰 데이터베이스는 각 쿠폰에 ‘bad’, ‘good’과 같은 등급 정보도 있다. best 쿠폰은 추천을 많이 한 사용자를 위한 쿠폰이며 good 쿠폰은 모든 사용자들에게 전달되는 쿠폰이고 bad 쿠폰은 사용하지 않기 때문에 사용자에게 전달하지 않는다.
- 10명 이상 추천한 사용자는 더 좋은 쿠폰을 받을 수 있다.

## 🍄 5. 쿠폰 보내는 과정을 그리기

### 🌻 5-1. 데이터베이스에서 구독자를 가져오는 것부터

- 쿠폰을 이메일로 보내려면 먼저 데이터베이스에서 구독자를 가져와야 한다. 이 단계는 **액션**이다.
- 구독자는 계속 바뀌기 때문에 지금 가져온 구독자와 다음에 가져온 구독자는 다를 수 있다. 그래서 이 단계는 실행 시점에 의존한다.
- 구독자를 데이터베이스에서 가져오면 사용자 목록을 얻을 수 있고 이는 **데이터**이다.

### 🌻 5-2. 데이터베이스에서 쿠폰 목록 가져오기

- 데이터베이스에서 쿠폰 목록을 가져오는 것도 **액션**이다. 쿠폰 데이터 베이스는 계속 바뀌기 때문에 가져오는 시점이 중요하다.
- 그래서 한번 가져온 쿠폰 목록은 가져온 시점의 목록이고, 이 목록은 **데이터**이다.

### 🌻 5-3. 보내야 할 이메일 목록 만들기

- 함수형 프로그래머는 처리 과정에 필요한 데이터를 만들기도 한다.
- 이메일 목록을 계획하는 것은 **계산**이다.
- 이메일 목록 계획하기 에서 생성된 이메일 목록은 다음 단계에서 사용할 **데이터**이다. 이메일 목록은 보내야 할 이메일을 계획한 결과이다.

### 🌻 5-4. 이메일 전송하기

- 이메일을 전송하는 것은 계산이다.
- 이메일 메시지에는 수신자와 보낸 내용이 이미 앞에서 다 만들었기 때문에 목록을 순회하면서 그냥 보내면 된다.

### 🌻 5-5. 이메일 만드는 부분을 자세히 살펴보기

- 함수형 프로그래머가 아니라면 이메일을 보내기 전에 이메일 목록 전체를 미리 만드는 것이 이상하다고 생각할 수 있다.
- 함수형 프로그래밍에서는 자연스러운 방법이다. 이메일 목록을 계획하는 계산을 더 작은 계산으로 나눠보자.
- 이메일 목록을 계획하는 계산은 구독자 목록 데이터와 쿠폰 목록 데이터를 받는다. 그리고 계산한 결과는 이메일 목록이다.
- 여기서 왜 계산을 만드는 것일까? 이메일을 보내는 것이 더 쉬워보이지 않을까 생각할 수 있다.
- 가능한 계산을 사용하려고 하는 이유는 테스트하기 쉽기 때문이다. 이메일을 실제로 보내고 결과를 주는 시스템은 테스트하기 어렵다. 하지만 결과가 이메일 목록 데이터인 시스템은 테스트하기 쉽다.
- 계산은 외부에 영향을 주지 않기 때문에 쉽게 테스트할 수 있다.
- 계산을 더 작은 계산으로 나눠보자면 쿠폰 목록에서 good 쿠폰 목록과 best 쿠폰 목록을 계산할 수 있다. 계산의 결과물로는 good 쿠폰 목록 데이터와 best 쿠폰 목록 데이터가 생긴다.
- 그리고 어떤 구독자가 good 쿠폰을 받을지 best 쿠폰을 받을지 결정하는 것을 계산으로 만들 수 있다.(rec_count ≥ 10)
- **계산**
    - 쿠폰 등급 결정하기
    - 쿠폰 등급이 “good”이면 good 이메일을 만들기, 쿠폰 등급이 “best”이면 best 이메일 만들기
- **데이터**
    - 구독자
    - good 쿠폰 목록
    - best 쿠폰 목록
    - 쿠폰 등급
    - 이메일
- 지금 시점에 계산을 더 나눌 수도 있다. 그리고 계산을 나누면 구현하기도 쉽다. 하지만 충분히 구현하기 쉽다고 생각되는 시점에서 더 나누는 것을 멈춰야 한다.

## 🍄 6. 쿠폰 보내는 과정 구현하기

### 🌻 6-1. 데이터베이스에서 가져온 구독자 데이터

- 구독자 데이터는 이메일 데이터베이스 테이블에서 가져온 것이다.
- 일반적으로 자바스크립트에서는 데이터베이스 행을 표현하기 위해 자바스크립트 객체를 사용한다.

```jsx
const subscriber = {
	email: "sam@pmail.com",
	rec_count: 16
};
```

- 함수형 프로그래밍에서 데이터는 언어에서 제공하는 단순 데이터 타입으로 표현한다. 언어에서 제공하는 데이터 타입은 알아보기 쉽고 사용하려고 하는 목적에도 잘 맞는다.

### 🌻 6-2. 쿠폰 등급은 문자열이다.

- 쿠폰 등급은 문자열로 표현한다. 다른 타입을 써도 좋지만 문자열이 편하다. 쿠폰 등급은 데이터베이스 테이블에 있는 rank 열값과 같다.

```jsx
const rank1 = "best";
const rank2 = "good";
```

### 🌻 6-3. 쿠폰 등급을 결정하는 것은 함수다.

- 자바스크립트에서 계산은 함수로 구현한다.
- 입력값은 함수 인자이고 출력값은 함수의 리턴값이다. 그리고 계산 내용은 함수의 본문이다.

```jsx
function subCouponRank(subscriber){
	if(subscriber.rec_count >= 10){
		return "best";
	}
	return "good";
}
```

- 이 함수는 명확하고 테스트하기 쉬우며 재사용할 수 있다.

### 🌻 6-4. 데이터베이스에서 가져온 쿠폰 데이터

- 구독자 데이터처럼 쿠폰 데이터도 자바스크립트 객체로 표현할 수 있다.

```jsx
const coupon = {
	code: "10PERCENT",
	rank: "bad"
};
```

- 테이블은 같은 모양의 자바스크립트 객체를 담고 있는 배열로 볼 수 있다.

### 🌻 6-5. 특정 등급의 쿠폰 목록을 선택하는 계산은 함수이다.

- 특정 등급의 쿠폰을 선택하는 계산도 함수로 구현한다.
- 입력값은 전체 쿠폰 목록과 선택할 등급이다. 출력값은 선택한 등급을 가진 쿠폰 목록이다.

```jsx
function selectCouponsByRank(coupons, rank) {
	const ret = [];
	for(var c = 0; c < coupons.length; c++){
		const coupon = coupons[c];
		if(coupon.rank === rank){
			ret.push(coupon.code);
		}
	}
	return ret;
}
```

- `selectCouponsByRank` 는 계산일까? 같은 입력값을 넣었을 때 같은 값이 나온다. 그러므로 계산이다. 같은 쿠폰 목록과 등급을 넣으면 항상 같은 쿠폰 목록이 나온다. 함수에 대해 호출 횟수가 영향을 줄까? 그렇지 않다. 아무리 호출해도 외부에 어떠한 영향도 주지 않는다. 따라서 selectCouponByRank() 함수는 계산이다.

### 🌻 6-6. 이메일은 그냥 데이터다.

- 보내야 할 이메일을 데이터로 표현해보자. 이메일 데이터는 보내는 주소와 받는 주소, 제목, 본문을 포함한다. 자바스크립트 객체로 표현할 수 있다.

```jsx
const message = {
	from: "newsletter@coupondog.co",
	to: "sam@pmail.com",
	subject: "Your weekly coupons inside",
	body: "Here are your coupons..."
}
```

### 🌻 6-7. 구독자가 받을 이메일을 계획하는 계산

- 먼저 구독자에 대한 이메일을 만드는 함수이기 때문에 구독자를 인자로 받아야 한다. 그리고 이메일에는 쿠폰 정보가 있어야 하기 때문에 쿠폰 목록도 입력값으로 받아야 한다. 구독자가 받아야 할 쿠폰이 good 쿠폰 목록일지 best 쿠폰일지 미리 알 수 없기 때문에 good 쿠폰 목록과 best 쿠폰 목록을 모두 입력값으로 받아야 한다. 그리고 결과값은 이메일 데이터이다.

```jsx
function emailForSubscriber(subscriber, goods, bests){
	var rank = subCouponsRank(subscriber);
	if(rank === "best"){
		return {
			from: "newsletter@coupondog.co",
			to: subscriber.email,
			subject: "Your best weekly coupons inside",
			body: `Here are the best coupons: ${bests.join(", ")}` 
		}
	}

	return {
			from: "newsletter@coupondog.co",
			to: subscriber.email,
			subject: "Your good weekly coupons inside",
			body: `Here are the good coupons: ${goods.join(", ")}` 
	}
}
```

- 이 함수는 계산이다. 외부에 어떤 영향도 주지 않고 입력값에 따라 이메일을 결정하고 리턴하는 것이 전부이다.

### 🌻 6-8. 보낼 이메일 목록을 준비하기

```jsx
function emailsForSubscribers(subscribers, goods, bests){
	const emails = [];
	for(var s = 0; s < subscribers.length; s++){
		var subscriber = subscribers[s];
		var email = emailForSubscriber(subscriber, goods, bests);
		email.push(email);
	}
	return emails;
}
```

### 🌻 6-9. 이메일 보내기는 액션이다.

- 일반적으로 액션도 계산처럼 함수로 구현한다. 그래서 함수만 보고 계산인지 액션인지 알아보기는 쉽지 않다. 액션도 일반적으로 입력과 출력이 필요하기 때문에 함수로 구현한다.

```jsx
function sendIssue(){
	var coupons = fetchCouponsFromDB();
	var goodCoupons = selectCouponsByRank(coupons, "good");
	var bestCoupons = selectCouponsByRank(coupons, "best");
	var subscribers = fetchSubscribersFromDB();
	var emails = emailsForSubscribers(subscribers, goodCoupons, bestCoupons);
	for(var e= 0; e < emails.length; e++){
		var email = emails[e];
		emailSystem.send(email);
	}
}
```

- 데이터를 파악하는 것으로 시작해서 계산과 추가 데이터를 도출하였다. 그리고 액션으로 모든 것을 묶었다.
- 데이터는 사용하는 데 제약이 많고 액션은 가장 제약이 없다.
- 이와 같이 데이터를 먼저 구현하고 계산을 구현한 후에 마지막으로 액션을 구현하는 것이 함수형 프로그래밍의 일반적인 구현 순서이다.

## 🍄 7. 계산에 대해 자세히 알아보기

- 계산은 입력값으로 출력값을 만드는 것이다. 실행 시점과 횟수에 관계없이 항상 같은 입력값에 대해 같은 출력값을 돌려준다.
- 계산은 함수로 구현한다.
- 계산에는 연산을 담을 수 있다. 계산은 입력값을 출력값으로 만드는 것을 표현한다. 계산을 언제 사용할지 또는 어떻게 사용할지는 때에 따라 다르다.
- 액션보다 계산이 좋은 점
    1. 테스트하기 쉽다. 계산은 언제 어디서나(로컬 장비, 빌드 서버, 테스트 장비) 원하는 만큼 테스트를 실행할 수 있다.
    2. 기계적인 분석이 쉽다. 학술 연구에 정적 분석이라는 것이 있다. 정적 분석에서 자동화된 분석은 중요하다.
    3. 계산은 조합하기 좋다. 계산을 조합해 더 큰 계산을 만들 수 있다.
- 계산의 예로는 더하기나 곱하기, 문자열 합치기, 쇼핑 계획하기 등이 있다.
- 계산을 쓰면서 걱정하지 않아도 되는 것
    1. 동시에 실행되는 것
    2. 과거에 실행되었던 것이나 미래에 실행할 것
    3. 실행 횟수
- 계산과 액션은 실행하기 전에 어떤 일이 발생할지 알 수 없다는 단점이 있다. 코드를 읽으면 예상 가능하지만 소프트웨어 측면에서는 함수는 블랙박스이다. 입력값으로 실행해야 결과를 알 수 있다. 이런 단점이 싫다면 계산이나 액션 대신 데이터를 사용해야 한다.
- 계산은 순수 함수 또는 수학 함수라고 부른다.

## 🍄 8. 이미 있는 코드에 함수형 사고 적용하기

- 함수형 프로그래머는 이미 있는 코드에 함수형 사고를 적용하기도 한다. 코드를 읽을 때도 액션과 계산, 데이터 관점으로 읽는다.
- 자회사에 수수료를 보내기 위해 만든 코드에 함수형 사고를 적용시켜보자.

```jsx
function figurePayout(affiliate){
	var owed = affiliate.sales * affiliate.commission;
	if(owed > 100) {
		sendPayout(affiliate.bank_code, owed); // 예측한 액션
	}
}

function affiliatePayout(affiliates){
	for(var a = 0; a > affiliates.length; a++){
		figurePayout(affiliates[a]);
	}
}

function main(affiliates) {
	affiliatePayout(affiliates);
}
```

- 이 코드는 함수형 코드라고 하기 어렵다. 액션이 하나가 아니다.
- 예측한 액션부터 시작해 점점 액션이 코드 전체로 펴져나간다.
1. 예측한 액션은 실제 돈을 송금하는 코드이다. 호출 시점이나 횟수가 중요하기 때문에 액션이 맞다.
2. 액션의 정의에 따르면 액션은 호출 시점이나 횟수에 의존한다. `figurePayout()` 함수는 액션인 `sendPayout()` 함수를 호출하기 때문에 역시 호출 시점과 횟수에 의존하게 된다. 그래서 `figurePayout()` 역시 액션이다.
3. 같은 논리로 `affiliatePayout()` 함수도 액션이다.
4. 안에서 액션을 호출하는 `main()` 함수도 같은 논리로 액션이다. 결국 코드 안쪽에 액션을 호출하는 코드 하나가 전체 프로그램을 액션으로 만든다.

## 🍄 9. 액션은 코드 전체로 퍼진다.

- 액션을 부르는 함수가 있다면 그 함수도 액션이다. 또 그 함수를 부른 다른 함수도 역시 액션이다. 이런 식으로 작은 액션 하나가 코드 전체로 퍼져 나간다.
- 이 이유로 함수형 프로그래머는 액션을 가능한 사용하지 않으려 한다. 액션을 쓰는 순간 코드 전체로 퍼져나가기 때문이다.
- 함수형 프로그래머는 액션을 사용하지만 매우 조심스럽게 사용해야 한다.

## 🍄 10. 액션은 다양한 형태로 나타난다.

- 자바스크립트 같은 언어에서 나도 모르게 액션을 호출하고 있을지도 모른다. 그리고 그것으로 인해 코드가 복잡해질 수 있다.

### 🌻 10-1. 함수 호출

```jsx
alert("Hello world!"); // 팝업창이 뜨는 것은 액션이다.
```

### 🌻 10-2. 메서드 호출

```jsx
console.log("hello"); // 콘솔에 출력한다.
```

### 🌻 10-3. 생성자

```jsx
new Date(); // 기본적으로 부르는 시점에 현재 날짜와 시간을 초기화하기 때문에 호출되는 시점에 따라 다른 값을 가진다.
```

### 🌻 10-4. 표현식

```jsx
// 변수 참조
y; // y가 공유되고 변경 가능한 변수라면 읽는 시점에 따라 값이 다를 수 있다.
// 속성 참조
user.first_name; // user가 공유되고 변경 가능한 객체라면 first_name은 읽는 시점에 따라 값이 다를 수 있다.
// 배열 참조
stack[0] // stack이 공유되고 변경 가능한 배열이라면 첫 번째 항목은 읽는 시점에 따라 값이 다를 수 있다.
```

### 🌻 10-5. 상태

```jsx
// 값 할당
z = 3; // 공유하기 위해 값을 할당했고 변경 가능한 변수라면 다른 코드에 영향을 주기 때문에 액션이다.
// 속성 삭제
delete user.first_name; // 속성을 지우는 것은 다른 코드에 영향을 주기 때문에 액션이다.
```

## 🍄 11. 액션에 대해 자세히 알아보기

- 액션은 외부 세계에 영향을 주거나 받는 것을 말한다. 그리고 액션은 실행 시점과 횟수에 의존한다.
- 자바스크립트에서 액션은 함수로 구현한다. 계산도 함수로 구현하기 때문에 구분하기 쉽지 않다.
- 액션으로 외부 세상에 영향을 줄 수 있다. 따라서 어떤 일을 하려는지 아는 것이 중요하다.
- 액션의 예로는 이메일 보내기, 계좌에서 인출하기, 전역변숫값 바꾸기, ajax 요청 보내기 등이 있다.
- 액션은 순수하지 않은 함수, 부수 효과 함수, 부수 효과가 있는 함수라 부른다.
- 액션은 다루기 힘들면서 우리가 소프트웨어를 실행하려는 가장 중요한 이유이다.
- 액션을 잘 사용하기 위한 방법
    1. 가능한 액션을 적게 사용한다. 액션을 전혀 쓰지 않을 수는 없다. 액션 대신 계산을 사용할 수 있는지 생각해 봐야 한다.
    2. 액션은 가능한 작게 만든다. 액션에서 액션과 관련 없는 코드는 모두 제거한다. 예를 들어, 액션에서 결정이나 계획과 관련된 부분은 계산으로 빼낼 수 있다.
    3. 액션이 외부 세계와 상호작용하는 것을 제한할 수 있다. 액션은 외부 세계에 영향을 주거나 받을 수 있다. 내부에 계산과 데이터만 있고 가장 바깥쪽에 액션이 있는 구조가 이상적이다.
    4. 액션이 호출 시점에 의존하는 것을 제한한다.

## 🍄 12. 정리

- 함수형 프로그래머는 액션과 계산, 데이터를 구분한다.
- 액션은 실행 시점이나 횟수에 의존한다. 일반적으로 액션은 외부세계에 영향을 주거나 받는다.
- 계산은 입력값으로 출력값을 만드는 것이다. 외부 세계에 영향을 주거나 받지 않고 실행 시점이나 횟수에 의존하지 않는다.
- 데이터는 이벤트에 대한 사실이다. 사실은 변하지 않기 때문에 영구적으로 기록 할 수 있다.
- 함수형 프로그래머는 액션보다 계산을 좋아하고 계산보다 데이터를 좋아한다.
- 계산은 같은 입력값을 주면 항상 같은 출력값이 나오기 때문에 액션보다 테스트하기 쉽다.